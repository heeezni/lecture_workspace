<자바 웹 프로그래밍>

1. 다음 설명 중 틀린 것은?

(1) ✅ Java 언어의 개발 플랫폼은 크게 JavaSE, JavaEE, JavaME 의 3가지가 있다
(2) ✅ JavaSE로 제작된 프로그램을 실행하려면,  이 프로그램을 사용하려는 자의 PC에 프로그램 코드가 배포되어 있어야 한다.
(3) ✅ 어떤 PC 에 이미 JavaSE 기반 프로그램이 배포되고 난 후, 프로그램에 수정이 필요하다하면 해당 PC의 프로그램은 수정본으로 재배포 되어져야 한다.
(4) ❌JavaEE 기반으로 제작되어진 프로그램의 배포 대상은 프로그램 사용자의 PC이다.

2. 웹어플리케이션에 대한 설명 중 맞는 것을 고르면 ?

(1) ❌JavaEE 기반으로 제작된 프로그램은 서버에 배포되며, 이 프로그램의 사용자는 JVM과 같은 전용 도구가 있어야 
	서버에서 실행된 프로그램의 실행 결과를 얻을 수 있다.
(2) ❌JavaEE 기반으로 작성된 웹어플리케이션의 디자인 영역을 담당하는 기술은  
	HTML,CSS,JS 등의 Front-End 기반의 기술들 이며, 이 기술들에 대한 해석 및 실행을 담당하는 쪽은 Server-Side 이어야 한다
(3) ✅ JavaEE 기반의 웹어플리케이션을 작성한 후, 개발자가 서버에  배포해 놓으면 다수의 사용자는 웹브라우저로 프로그램의 실행을 요청하게
     되는데, 이때 서버측에 배포된 파일중 Java 클래스는 서버측의 컴퓨터에서 실행되어 버리지만,  
	Font-end 관련 기술들은 실행 시키지는 않고, 단순히 읽어들인 후 클라이언트에게 그대로 전송을 해버린다. 
(4) ✅ 위(3)번과 같이 Font-End 기술과 관련된 파일들이 그대로 클라이언트에 전송되 버리는 이유는, 
	Font-End 기술을 해석 및 실행할 수 있는 전용 프로그램은 웹브라우저이기 때문이다. 
(5) ✅ 결국 웹어플리케이션은 중앙의 서버가 실행을 담당하므로 서버 컴퓨터의 실행 환경, 사양, 성능 등이 중요한 반면에, 
	웹애플리케이션의 사용자는 어떠한 추가적 설치나 환경을 구축해야 할 부담이 없이 오직 웹브라우저 하나만 준비되어 있으면 된다.
(6) ❌ 유지 보수성이나 배포의 편의성을 고려해본다면, JavaSE가 JavaEE에 비해 유리하다.

3. 다음 중 틀린 것을 고르면?

(1) ✅ JavaSE 로 어플리케이션을 개발하려면 JDK자바개발도구)를 설치해야 하며, 이 JDK에는 String, Calender 등 개발에 필요한 각종 API들이 포함되어 있다.
(2) ❌ JavaEE 로 서버 기술을 구현하려면 서버 구축과 관련된 클래스를 포함한 API 즉 JavaEE API가 필요하므로 JEEDK 의 설치가 필요하다. 
(3) ✅ JavaEE 기반의 프로그램 개발 시, 개발자가 자신의 PC에 설치해야 할 JavaEE 개발용 SDK는 없는 이유는 Sun에서는 기준을 제시하면, 
    그 기준에 따라 각 벤더사들은 서버 등을 제작하면서, 개발자들이 서버 구축에 사용할 클래스 포함한 API 를 , 해당 제품에 넣어두기 때문이다. 
    즉 JavaEE 개발을 위해서는 서버만 있으면 되고 이 서버안에 개발에 필요한 API 가 포함되어 있다.
(4) ❌JavaEE 기반 웹어플리케이션 개발에 사용될 API가 각 벤더사에 제공하는 서버에 들어있을 경우, 
	각 제품에 포함된 API를 이루는 클래스명, 메서드명이 서로 틀리게 되므로, 개발자는 서버 제품 선택 시 신중해야 하며, 
	서버 제품이 바뀌면 개발 코드도 변경되어야 한다.

4.다음 설명 중 틀린 것을 모두 고르면?

(1) ❌JavaEE 기반의 웹서비스를 구축하려면 JavaEE 기반의 코드가 실행될 수 있는 전용 서버 프로그램을
    이용해야 하는데, 이 서버 프로그램을 개발하는 업체는 바로  Sun 사이다.
(2) ❌JavaEE 전용 서버의 제조사마다 작동 방식이 틀리므로 , 제품이 바뀌면 자바 개발자들은 웹프로그램
    소스 코드도 변경해야 한다.
(3) ✅ HTML/CSS같은 정적 자원들을 서비스하기 위한 용도의 서버를 일반적으로 웹서버라 하며, JSP와 같은
     동적 컨텐츠를 실행할 수 있는 웹서버를 WAS(Web Application Server)라 한다.
(4) ✅ WAS 제품의 종류엔 WebLogic, JBoss, JEUS 등이 있다.
(5) ❌ 사용중인 WAS가 변경 될 경우, 웹어플리케이션 코드도 해당 제품에 맞게 다시 변경해야 한다. 

5. 다음 중 `규모가 큰` JavaEE 기반 웹서비스 구축을 위한 가장 이상적인 조합은?
(1) 서버용 OS는 Window, DB는 MSSQL , 웹서버는 IIS  구성
(2) 서버용 OS는 Linux, DB는 MySQL , 웹서버는 Tomcat 으로 구성
(3) 서버용 OS는 Window, DB는 Oracle , 웹서버는 Tomcat 으로 구성
(4) ✅ 서버용 OS는 Unix, DB는 오라클 , 서버는 WAS로 구성

개발 윈도우 -  리눅스  -  tomcat/Resin(유료) -  MySQL (중, 소) 
             jsp, java, php
-----------------------------------------------------------------------
개발 윈도우 -  유닉스  - WebLogic/JBoss -  Oracle (대형)

6. 다음 설명 중 틀린 것은?

(1) ✅JavaEE 기반의 WAS(웹어플리케이션 서버)의 종류는 오라클사의 WebLogic, 레드햇의 JBoss, 티맥스소프트의 JEUS 등과 , 
	Apache의 Tomcat, caucho의 Resin과 같은  웹컨테이너가 있다
(2) ✅ 웹서버를 Tomcat으로 개발하던 WebLogic으로 개발하던 클래스나 jar파일은 반드시 WEB-INF/lib 디렉토리에 두어야 한다는 스팩에는 변함이 없다.
(3) ✅WebLogic, JBoss 등 javaEE기반의 WAS(웹어플리케이션 서버)는 모두 Sun의 JavaEE 스팩을 준수하여 제작되었으므로, 
	WAS가 바뀌었다고 해도 기존 소스 코드가 변경되는 일은 없다.
(4) ❌JavaEE 개발에 필요한 클래스 및 API의 구현체인 jar파일은 Sun의 웹사이트를 통해 다운받으면 된다.

7. JavaEE(Enterprise Edition)의 기업 업무용 어플리케이션 시장의 독점을 견제하기 위한 마이크로 소프트의 개발 플랫폼은 무엇이며 JavaEE와의 차이점을 설명하시오.
.NET (닷넷) 
- JavaEE는 오픈 표준 기반의 엔터프라이즈 플랫폼이고,
- .NET은 마이크로소프트의 윈도우 중심 독자 생태계로 JavaEE의 시장 독점을 견제하려 했던 플랫폼입니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<HTTP 프로토콜 (통신규약)>

8. 다음 중 틀린 것은?

(1) ✅ 웹서버와 웹브라우저가 서로 데이터를 주고 받을 때 사용되는 통신 규약은 HTTP 이다.
(2) ✅ HTTP에서 웹브라우저가 서버에 원하는 내용을 요청하면, 서버는 이에 대한 결과를 적절한 형식으로
    응답해주게 되는데, 이 적절한 형식은 HTML,XML,Image 등 웹브라우저가 해석 및 실행할 수 있는 형식이
    라면 어떤 형태이던 가능하다.
(3) ❌웹서버상에 이미지, HTML, CSS 코드와 같은 정적자원을 올려놓고 웹브라우저로 이 자원을 요청하게 될 경우, 
     웹서버는 해당 자원들을 서버에서 해석 및 실행시켜 버린다. 
     (→ 서버 실행 X 클라이언트 측 웹 브라우저가 실행)
(4) ✅만일 서버에서 전송되어진 결과물이 웹브라우저가 해석 및 실행할 수 없는 대상일 경우, 다운로드 창이 뜨게 된다.
     (- 404에러 : 해당 자원 자체가 없음 )

HTML 주 목적: 어떻게 보여줄까?
XML 주 목적: 데이터를 어떻게 구조화 시킬까?

9. HTTP 프로토콜의 전송 방식에 대한 설명 중 틀린 것을 고르면?

(1) ✅ HTTP 상에서 클라이언트와 서버는 메시지를 주고 받을때 Header(머리)와 Body(몸) 형식으로 구성하여
   통신한다.
(2) ✅ HTTP 통신에 사용되는 형식에서, 내용은 body에 적재하고 요청 및 응답에 대한 추가적 설명은 header에 적재한다.
(3) ✅ 클라이언트가 웹서버에게 요청하는 목적 알리는 수단을 가리켜 HTTP 메서드라 하며 ,
    대표적인 것에는 GET과 POST가 있다. 
(4) ❌클라이언트가 서버로부터 단순히 데이터를 가져오는 게 목적이라면 Post 방식을 이용한다.
(5) ✅ 클라이언트가 서버로 데이터를 전송하는게 목적이라면 Post 방식을 이용한다.

10. HTTP 프로토콜에 대한 설명 중 올바른 것은?

(1) ❌Stateful(상태 유지) 프로토콜이다.
(2) ❌브라우저로 특정 웹사이트를 방문하는 시점부터 연결은 계속 유지되지만 브라우저를 종료하는 순간이
     바로 연결이 끊기게 되는 시점이다.
(3) ❌특정 웹사이트 접속시, 브라우저에 HTML 및 이미지가 뜬다면 
     그 파일들은 이미 클라이언트의 로컬 PC로 전송되어 있는 상태이며 영구 보존된다.
     (-> 브라우저가 가지고 있는 **임시 디렉토리**에 다운 받아져있는 상태)
(4) ✅브라우저는 HTTP기반의 파일들을 전송 받은 후, 이를 해석하는 프로그램이지만, 
    만일 해석이 불가능한 파일 형식에 대해서는 다운로드 창이 뜨게 된다.
(5) ❌자바스크립트 소스를 외부파일로 링크 시키면 소스를 노출시키지 않으므로 보안이 가능하다.
(6) ❌네이버에서 마음에 드는 사진을 갖고자 마우스 우측 버튼을 눌러 ‘다른이름으로 저장 하기’ 기능을 시도하였으나 
     우측 마우스 실행을 막아놓았다면 사진을 내 PC로 다운로드 받는 것은 불가능하다.
----------------------------------------------------------------------------------------------------------------------------------------------------------
<서블릿>
11. 다음 설명 중 맞는 것을 모두 고르면?

(1) ✅ 웹서버에서 실행되는 javaEE 기반의 클래스를 서블릿이라 한다.
(2) ❌서블릿을 실행시키려면, 웹브라우저의 URL에 직접 서블릿 클래스명을 호출하면 된다.
     -> 매핑해야 함 
(3) ❌서블릿 코드 내에 HTML 코드는 포함할 수 없다.
     -> out.print로 가능 
(4) ❌JSP와 서블릿 중 HTML코드를 보다 쉽게 작성할 수 있는 기술은 서블릿이다.
(5) ❌JSP와 서블릿은 서로 관련성이 전혀 없는 기술이며, 각각 독자적인 방법으로 실행되어진다.

12. 다음 설명 중 틀린 것을 고르면?

(1) ✅ 서블릿 클래스내에 HTML 코드를 포함하여 디자인을 표현하는 방식은 효율성이 너무 떨어지므로 , 
    디자인 코드를 보다 쉽고 빠르게 작성하기 위해서 고안된 기술이 바로 JSP 이다.
(2) ✅ JSP와 서블릿은 별도의 존재가 아니라, JSP로 작성된 코드는 실행전에 자동으로 서블릿 코드로 변경
     되어지므로, JSP는 곧 서블릿이라 할 수 있다.
(3) ✅ JavaEE기반의 서버에서 실행되어지는 기술은 오직 서블릿 밖에 없으며, JSP는 단지 서블릿을 보다 쉽고
     빠르게 작성할 수 있는 수단을 제공하는 것 뿐이므로, 개발자가 JSP를 작성할 경우 결국 서블릿을 간접적
     으로 작성하게 되는 것이다.
(4) ❌ JSP를 서블릿 클래스로 변환시키는 주체는 개발자이다.

13. 서블릿에 대한 설명 중 틀린 것은?

(1) ✅ HTML 태그 혼용 시 코드가 복잡해지는 서블릿의 단점은 JSP로 해결할 수 있다.
(2) ✅ JSP는 서블릿으로 변환되어 실행된다. 따라서 JSP가 곧 서블릿이다.
(3) ❌ 서블릿은 컨테이너에 의해서만 자동으로 생성되어지며 프로그래머가 작성할 수는 없다.
(4) ✅ JSP의 <%! %>(선언부) 영역에 코드를 작성하는 것은 서블릿의 멤버 영역에 코딩한 것과 같다.
(5) ✅ JSP의 <% %>(스크립틀릿) 영역에 코드를 작성하는 것은 서블릿의 service() 메서드에 코딩한 것과 같다.

14.다음 설명 중 틀린 것을 고르면?

(1) ❌ 서블릿의 인스턴스는 클라이언트의 요청이 있을 때마다 메모리에 생성되어진다.
     (-> 서블릿은 단 하나만 생성되고, 클라이언트 요청이 들어올 때마다 새로운 쓰레드가 생성)
(2) ✅ 클라이언트의 요청이 있을때, 서버측에서는 요청 처리를 위한 쓰레드가 생성되며, 
    이 쓰레드에 의해 서블릿의 service() 메서드가 실행되어 진다.   
(3) ❌ 서블릿은 JSP이다.
     (-> 서블릿이 JSP로 변경되는 일은 없기 때문에)
(4) ❌ JSP가 서블릿으로 변경되는 시점은 클라이언트의 요청이 있을 때마다 이다.
     (->  최초 요청 시 한 번만 서블릿으로 변경)
(5) ✅ JSP를 서블릿으로 변경하는 주체는 톰켓과 같은 웹컨테이너(JavaEE를 이해하는 소프트웨어)이다. 
(6) ❌ JSP는 클라이언트의 최초 요청이 있을때 서블릿으로 변경되어 인스턴스가 생성되며, 이 인스턴스 생성
     이후부터는 요청이 있을 때마다 쓰레드가 생성되어, 요청을 처리하게 된다.

15. 다음 설명 중 틀린 것은?

(1) ✅ 서블릿 클래스의 자료형은 HttpServlet 이며, 서블릿의 최상위 객체는 Servlet 인터페이스이며,
   이 인터페이스에는 서블릿으로서 갖추어쟈 할 기본이 되는 메서드가 정의되어 있다. (ServletLifeCycle method)
   (Servlet → GenericServlet → HttpServlet)
(2) ❌JavaEE 기반의 서버 제품마다 각각 기술력이 다르므로, Tomcat에서는 웹요청을 서블릿이 처리하지만,
    JBoss에서는 전혀 다른 명칭의 객체와 메서드가 웹요청을 처리한다. 
(3) ❌개발자가 서블릿 클래스를 정의한 후에, new 연산자로 인스턴스를 미리 생성해 놓아야 클라이언트의
     요청을 받을 수 있다. 
(4) ❌서블릿을 포함한 JavaEE 관련 API 객체들은 jar파일 형태로 존재하는데, 이 jar 파일은 오라클사에서
     다운로드 받아야 한다. 
(5) ✅ Tomcat, JBoss, WebLogic, JEUS 등 WAS 제품은 다양하지만, 각 제품의 종류에 상관없이 개발자는 항상
     동일한 코드를 유지할 수 있는 이유는 , JavaEE 기반의 WAS들은 자바의 기준 스팩을 준수하여 개발이
     되어 지기 때문이다. 

16. HttpServlet 클래스의 생명주기에 대한 설명 중 맞는 것은?

(1) ❌ 개발자에 의해 작성된 서블릿을 서버에 배포해 놓으면 최초의 요청을 시도하는 클라이언트에 의해
   인스턴스가 생성되며, 이때 서블릿은 초기화가 진행되는데, 이때 초기화를 담당하는 생명주기 메서드가
   service() 이다. 
(2) ❌일단 서블릿의 인스턴스가 생성된 후에는 클라이언트의 요청이 추가로 발생하더라도 인스턴스는 중복
   생성되지 않으며, 대신 쓰레드가 생성되어 요청을 처리하게 된다, 이때 이 요청을 처리하기 위한 생명주기
   메서드가 바로 init() 메서드이다. 
   (-> service()메서드)
(3) ✅ service() 메서드가 요청을 처리하기 위해서는 클라이언트가 시도한 요청에 대한 정보를 알아야 하므로,
     이 요청 정보를 담고 있는 객체인 HttpServletRequest를 인수로 받도록 API가 정해져 있다.
(4) ✅ 하나의 요청 처리가 완료되려면, 요청 및 응답이 모두 성공해야 하므로 service() 메서드는 요청 정보 뿐
     만 아니라 응답 정보를 저장할 수 있는 객체도 필요로 하게 되므로, 매개변수로 응답객체도 전달받도록 
     API가 정해져 있다.
(5) ❌ 클라이언트의 요청이 Get방식일 경우엔 doGet() 메서드가 service() 메서드를 호출한다.

17. 다음 설명 중 틀린 것을 고르면?

(1)✅ doGet() 과 doPost() 등의 doXXX()형 메서드는 service() 메서드에 의해 호출되어진다.
(2)✅ service() 메서드의 실행은 쓰레드가 담당한다.
(3)❌ init() 메서드는 쓰레드에 의해 호출된다. 
(4)✅ 서블릿 인스턴스가 메모리에 올라가는 시점은 컴파일 후, 최초로 클라이언트의 요청이 있을 때이다.
(5)❌ 결국 개발자가 요청을 처리하기 위해 재정의할 메서드는 service() 메서드이다.
   (-> doXXX형 메서드임)

18. 다음 설명 중 맞는 것은?
(1)❌서블릿의 생명주기 메서드 중 가장 먼저 호출되어 지는 메서드는 init() 메서드이며, 
   클라이언트의 요청이 있을 때마다 호출되어 진다.
(2)❌init()메서드는 서블릿의 초기화를 담당하므로, 서블릿의 생성자로 볼 수 있다.
    (init() ≠ 생성자, 생성자가 먼저 호출됨)
(3)❌서블릿은 컨테이너가 생성하므로 생성자가 존재할 수 없다.
(4)✅ 서블릿의 생명주기와 관련된 메서드에는 init(), service(), destroy() 가 있다.

19. 다음 설명 중 틀린 것은?

(1) ✅ 서블릿 객체가 생성되어 질 때, 자신이 속한 웹어플리케이션의 정보를 컨테이너로부터 얻게 되는데
    이 정보를 가진 객체가 바로 ServletConfig 인터페이스이다.
(2) ❌ 서블릿 객체 생성시, 생성자 보다 앞서 호출되는 메서드가 바로 init() 메서드이다.
(3) ✅ 웹어플리케이션의 서블릿 환경정보를 담는 ServletConfig 객체는 init() 메서드의 인수로 전달되어 
진다.
(4) ✅초기화 정보 중엔 web.xml 파일에 설정된 파라미터 값 정보도 포함된다.

20. 서블릿에 대한 설명 중 틀린 것은?

(1)✅ HttpServletRequest는 사실, JSP에서 사용하였던 request 내장 객체의 데이터 타입이었다.
    (서블릿의 service(HttpServletRequest request) = <% request.getParameter() %>)
(2)✅ HttpServletResponse는 사실 JSP에서 사용하였던 response 내장 객체의 데이터 타입이었다.
(3)✅HttpServletRequest, HttpServletResonse 객체는 인터페이스이므로 프로그래머가 new 할 수 없으며
  '요청이 있을 때마다' 컨테이너에 의해 메모리에 올라간다.
   (스레드와 함께 빨간동그라미+파란동그라미)
(4)❌하나의 요청이 끝나는 시점은 결국 웹서버 컨테이너 가동을 중단하는 시점이다.
   (tomcat이 컨텐츠 응답했을때 끝남 - 자기가 만든 html문서를 웹브라우저에 뿌렸을때)
(5)❌ 하나의 요청이 끝나는 시점은 결국 doXXX형 메서드의 닫는 괄호를 만나는 시점이고, 이 시점에 
  쓰레드와 request, response 객체들은 모두 소멸된다.

21. 다음 설명 중 맞는 것은?

(1) ❌ 서블릿의 메서드 중 init(),service(),destroy() 를 생명주기 메서드라 하며, 
    HttpServlet 클래스에 정의되어 있다.
    (->Servlet 인터페이스에 있었음)
(2) ❌ init() 메서드는 서블릿의 초기화를 담당하는 생성자이다. 
(3) ❌ init() 메서드는 service() 메서드가 호출 되고 난 직후에 컨테이너에 의해 호출되어 진다.
(4) ✅ init() 메서드는 서블릿의 일생에 단 한번만 호출되어 진다.

22. 다음 설명 중 틀린 것은?

(1) ✅ Servlet 인터페이스는 서블릿으로서 반드시 가져야 할 가장 기본이 되는 5가지 메서드만을 정의해 놓은
     서블릿 API의 최상위 객체이다
(2) ✅ 서블릿에게 필수적인 업무를 정의해 놓은 클래스는 GenericServlet 클래스이다. (애매..)
(3) ✅ HttpServlet 클래스는 GenericServlet 클래스를 상속 받으며, HTTP기반의 요청을 처리하기에 최적화된 서블릿이다.
(4) ❌ GenericServlet 은 Servlet 클래스를 상속받고 있으며, HttpServlet 은 GenericServlet 인터페이스를 구현하고 있다.
(5) ✅ Sun에서는 서블릿 API의 스팩만을 명시하며 이 서블릿의 API를 실제 구현할 의무는 서버 제작자에게
    있다. 따라서 서블릿 관련 API의 구현체인 jar 파일은 현재 사용중인 서버가 보유하고 있다.

23. 다음 설명 중 틀린 것은?

(1) ✅ 서블릿 객체가 생성되어 질 때, 자신이 속한 어플리케이션의 환경 정보를 컨테이너로부터 부여 받게
     되는데 이 정보를 가진 객체가 바로 ServletConfig 인터페이스이다.
(2) ❌ 서블릿 객체 생성시, 생성자 보다 앞서 호출되는 메서드가 바로 init() 메서드이다.
(3) ✅ 어플리케이션의 정보를 담는 ServletConfig 객체는 init() 메서드의 인수로 전달되어 진다.
   (-> init(ServletConfig config) 메서드는 서블릿 초기화 시 호출되며,
        ServletConfig 객체를 통해 web.xml의 초기화 파라미터 등 정보가 전달)
(4) ✅ 초기화 정보 중엔 web.xml 파일에 설정된 파라미터 값 정보도 포함된다.

24. 다음 설명 중 틀린 것은?

(1) ✅ 서블릿의 API는 클라이언트의 “요청” 에 대한 개념을 HttpServletRequest 인터페이스로 정의해 놓았으며 
    이 객체를 이용하여 클라이언트의 요청과 관련된 많은 업무를 처리할 수 있다.
(2) ✅ HttpServletRequest 인터페이스에 대한 API 문서는 Sun사에서 제공한다.
(3) ❌ 개발자는 doXXX()형 메서드보다는 주로 service() 메서드를 재정의함으로서 웹서비스를 구현한다.
(4) ❌ 클라이언트와 서버의 개념은 HTTP 프로토콜에서만 사용되는 개념이다.

-----------------------------------------------------------------------------------------------------------------------------------------




